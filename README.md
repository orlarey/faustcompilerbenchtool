# Faust Compiler Benchmark Tools

**Faust Compiler Benchmark Tools** is a suite of utilities designed to analyze and measure the performance of the C++ code generated by the Faust compiler. These tools are particularly useful when developing new compilation strategies, as they ensure correctness and evaluate performance impacts.

## Tools Overview

Assuming you have compiled `foo.dsp` into `foo.cpp`, the following tools are available:

1. **`fcbenchtool foo.cpp`**  
   Generates a binary (`foo`) to measure the performance of the `compute` method in `foo.cpp`.

2. **`fcasmtool foo.cpp`**  
   Produces an assembly file (`foo.s`) for inspecting the generated assembly code.

3. **`fcanalyze foo.cpp`**  
   Performs static analysis on `foo.cpp` to identify potential issues.

4. **`fcplottool foo.cpp`**  
   Creates a binary (`foo`) that, when executed, prints or plots the impulse response of `foo.cpp`.

5. **`fccomparetool foo1.cpp foo2.cpp`**  
   Compares the impulse responses of `foo1.cpp` and `foo2.cpp` using `fcplottool`.

6. **`fcdebugtool foo.cpp`**  
   Similar to `fcplottool`, but produces a debug-enabled binary for use with `gdb`.
   
7. **`fcexplorer.py`**: A Python script to explore various Faust compilation options and their impact on the generated C++ code.

8. **`fcanalyze.py`**: A Python script to analyze multiple DSP files with different FAUST configurations using static analysis to detect warnings and errors.


---

## Installation

The tools can be installed with the following command:

```bash
sudo ./install.sh
```

- **Binaries**: Installed in `/usr/local/bin`.
- **Dependencies**: Stored in `/usr/local/share/fcbenchtool`.

---

## Main Tool: `fcbenchtool`

The primary tool, `fcbenchtool`, is used to benchmark the performance of C++ implementations generated by Faust. This involves generating various implementations (e.g., `foo1.cpp`, `foo2.cpp`, etc.) by varying Faust compiler options and comparing their performance.

### How It Works

1. **Code Wrapping**:  
   `fcbenchtool` wraps the original C++ source file between a header and footer to enable performance measurement.
   
2. **Optimized Compilation**:  
   The code is compiled with the following options:
   - `-O3` (high optimization)
   - `-ffast-math` (faster floating-point computations)
   - `-march=native` (architecture-specific optimizations)

3. **Performance Measurement**:  
   The resulting binary measures the time (in milliseconds) to process 1 second of sound (44100 samples). The benchmark iterates until the minimal result remains stable over at least 1000 iterations. This iteration count can be customized.

### Workflow Example

```bash
# Step 1: Generate C++ code from a Faust file
faust foo.dsp -o foo.cpp

# Step 2: Compile with fcbenchtool
fcbenchtool foo.cpp

# Step 3: Execute the binary and analyze performance
sudo ./foo
sudo ./foo 250  # Custom iteration count
```

### Custom Compiler and Extensions

You can specify a custom compiler using the `CXX` environment variable and define a custom file extension for the generated binary. For example:

```bash
faust foo.dsp -o foo.cpp
CXX=clang++-19 fcbenchtool foo.cpp .cl19
sudo ./foo.cl19
```


## Additional Tools

### `fcasmtool`:  
Use to inspect the assembly code generated by the C++ compiler.

```bash
fcasmtool foo.cpp
```

### `fcanalyze`:  
Run static analysis to detect potential issues in `foo.cpp`.

```bash
fcanalyze foo.cpp
```

### `fcplottool` and `fccomparetool`:  

- Plot the impulse response of `foo.cpp`:

  ```bash
  fcplottool foo.cpp
  sudo ./foo
  ```

- Compare impulse responses between two files:

  ```bash
  fccomparetool foo1.cpp foo2.cpp
  ```

### `fcdebugtool`:  
Build a debug-enabled binary for analysis with `gdb`:

```bash
fcdebugtool foo.cpp
gdb ./foo
```

### `fcexplorer.py`:  
Explore various Faust compilation options to observe their impact on the generated C++ code.

```bash
fcexplorer.py -mcd "0 2 4 8" -vec "" foo.dsp...
```

will generate the 8 corresponding C++ files. The generated files will be named `foo_mcd0.cpp`, `foo_mcd0_vec.cpp`, `foo_mcd2.cpp`, etc. In the example `-vec ""`  indicates an option that can be present or not, without additional arguments.


### `fcbenchgraph.py`

**fcbenchgraph.py** is a Python script designed to benchmark multiple DSP files with different FAUST parameter configurations and generate comparative performance graphs.

#### Features

- Benchmark multiple `.dsp` files with various FAUST compiler configurations
- Generate performance comparison matrices and statistics
- Create visual graphs showing performance differences across configurations
- Support for custom iteration counts and binary extensions
- Automatic graph generation with matplotlib (optional)

#### Usage

```bash
fcbenchgraph.py <file_pattern> <faust_config1> [faust_config2] ... [OPTIONS]
```

#### Parameters

- **file_pattern**: Glob pattern for `.dsp` files to benchmark (e.g., `"*.dsp"`, `"tests/**/*.dsp"`)
- **faust_config**: One or more FAUST parameter sets to test (e.g., `"-lang cpp"`, `"-lang cpp -vec"`)

#### Options

- `--iterations N`: Number of benchmark iterations (default: 1000)
- `--extension EXT`: Extension for generated binaries (default: `.bench`)
- `--no-graph`: Disable graph generation
- `--graph-output FILE`: Custom graph filename (default: `benchmark_YYYYMMDD_HHMMSS.png`)

#### Examples

1. **Basic benchmarking with single configuration**:

   ```bash
   fcbenchgraph.py "*.dsp" "-lang cpp"
   ```

2. **Compare multiple configurations**:

   ```bash
   fcbenchgraph.py "tests/impulse-tests/dsp/*.dsp" "-lang cpp" "-lang cpp -vec" "-lang cpp -double"
   ```

3. **Custom iterations and graph output**:

   ```bash
   fcbenchgraph.py "*.dsp" "-lang cpp" "-lang rust" --iterations=500 --graph-output=my_benchmark.png
   ```

#### Output

The script generates:

1. **Console output**:
   - Progress information during benchmarking
   - Results matrix showing execution times in milliseconds
   - Configuration details and statistics
   - Global success rates

2. **Graph file** (if matplotlib is available):
   - Visual comparison of performance across configurations
   - Line plots showing execution times for each DSP file
   - Command information and generation timestamp
   - Automatic filename with timestamp if not specified

#### Prerequisites

- FAUST compiler must be installed and accessible
- `fcbenchtool` must be installed (from this toolkit)
- Python 3 with standard libraries
- matplotlib (optional, for graph generation): `pip install matplotlib`

#### Process

For each DSP file and configuration combination:

1. Compiles the DSP file using FAUST with specified parameters
2. Uses `fcbenchtool` to create a benchmarking binary
3. Executes the binary to measure performance
4. Collects timing results and generates statistics
5. Creates comparative visualizations (if matplotlib is available)


### `fcanalyze.py`

**fcanalyze.py** is a Python script designed to analyze multiple DSP files with different FAUST parameter configurations using static analysis. Instead of measuring performance like `fcbenchgraph.py`, it focuses on detecting warnings, errors, and potential issues in the generated C++ code.

#### Features

- Analyze multiple `.dsp` files with various FAUST compiler configurations
- Use `fcanalyzetool` to perform static analysis on generated C++ code
- Generate analysis comparison matrices and statistics
- Detect warnings, errors, and potential code issues
- Identify the most problematic files across configurations

#### Usage

```bash
fcanalyze.py <file_pattern> <faust_config1> [faust_config2] ... [OPTIONS]
```

#### Parameters

- **file_pattern**: Glob pattern for `.dsp` files to analyze (e.g., `"*.dsp"`, `"tests/**/*.dsp"`)
- **faust_config**: One or more FAUST parameter sets to test (e.g., `"-lang cpp"`, `"-lang cpp -vec"`)

#### Examples

1. **Basic analysis with single configuration**:

   ```bash
   fcanalyze.py "*.dsp" "-lang cpp"
   ```

2. **Compare multiple configurations**:

   ```bash
   fcanalyze.py "tests/impulse-tests/dsp/*.dsp" "-lang cpp" "-lang cpp -vec" "-lang cpp -double"
   ```

3. **Analyze specific file patterns**:

   ```bash
   fcanalyze.py "examples/*.dsp" "-lang cpp" "-lang rust"
   ```

#### Output

The script generates console output including:

1. **Progress information** during analysis for each file and configuration
2. **Results matrix** showing analysis status:
   - `âœ“ CLEAN`: No issues found
   - `XW/YE`: X warnings and Y errors found
   - `FAUST_ERR`: FAUST compilation failed
   - `ANALYSIS_ERR`: Static analysis failed

3. **Configuration details** and statistics per configuration
4. **Global statistics** including success rates
5. **Most problematic files** section listing files with the most issues

#### Prerequisites

- FAUST compiler must be installed and accessible
- `fcanalyzetool` must be installed (from this toolkit)
- Python 3 with standard libraries

#### Process

For each DSP file and configuration combination:

1. Compiles the DSP file using FAUST with specified parameters
2. Uses `fcanalyzetool` to perform static analysis on the generated C++ code
3. Parses analysis output to extract warnings, errors, and other issues
4. Collects results and generates comprehensive statistics
5. Provides a summary of code quality across different configurations

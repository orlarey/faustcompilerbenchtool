# Faust Compiler Benchmark Tools

A set of tools to analyze and measure the performance of the C++ code generated by the Faust compiler. These tools can be used when developing new compilation strategies to ensure the code remains correct and to measure the performance impact.

Assuming we have previously compiled `foo.dsp` into `foo.cpp`, then:

1. **`fcbenchtool foo.cpp`**: Produces a binary file `foo` that measures the performance of the `compute` method in `foo.cpp`.
2. **`fcasmtool foo.cpp`**: Produces an assembly file `foo.s` that can be used to inspect the assembly code generated by the C++ compiler.
3. **`fcanalyze foo.cpp`**: Reports potential problems in `foo.cpp` via static analysis.
4. **`fcplottool foo.cpp`**: Generates a binary file `foo` that, when executed, prints/plots the impulse response of `foo.cpp`.
5. **`fccomparetool foo1.cpp foo2.cpp`**: Uses `fcplottool` to check that the impulse responses of `foo1.cpp` and `foo2.cpp` are the same.
6. **`fcdebugtool foo.cpp`**: Similar to `fcplottool`, but the generated binary is in debug mode and can be executed by `gdb` to debug its execution.

## Installation
The scripts are installed in the `/usr/local/bin` directory, and the dependencies in the `/usr/local/share/fcbenchtool` directory. 

```bash
sudo ./install.sh
```

## `fcbenchtool`
The main tool is `fcbenchtool`. The idea is to generate various C++ implementations (e.g., `foo1.cpp`, `foo2.cpp`, etc.) from `foo.dsp` by varying the Faust compiler options. Then, we compare the performances of all these implementations by translating them into binaries using `fcbenchtool foox.cpp` and executing the resulting binaries (e.g., `foo1`).

The `fcbenchtool` wraps the original `foox.cpp` source file between a header and footer equipped to measure the performance of the code. It compiles the source file with `-O3 -ffast-math` optimizations and `-march=native`. The resulting binary can then be executed, and it will provide timing information. The timing information is the time in milliseconds it takes to process 1 second of sound (44100 samples). The program will iterate the measurement until it has the same minimal result for at least 1000 iterations. The minimal number of iteration can be changed when calling the binary.

### workflow

1. Generate C++ code from a Faust file.
2. Compile the generated C++ code with `fcbenchtool` to inject code that measures the execution time of the compute method for a count of 44100 samples.
3. Execute the resulting binary. The result is expressed in milliseconds. The program will iterate the measurement until it has the same minimal result for at least 1000 iterations. The minimal number of iteration can be changed when calling the binary.


```bash
faust foo.dsp -o foo.cpp
fcbenchtool foo.cpp
sudo ./foo
sudo ./foo 250
```

The `fcbenchtool` utility allows you to specify a custom compiler using the CXX environment variable and an optional file extension for the generated binary. 

```bash
faust foo.dsp -o foo.cpp
CXX=clang++-19 fcbenchtool foo.dsp .cl19
sudo ./foo.cl19
```

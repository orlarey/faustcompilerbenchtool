# Faust Compiler Benchmark Tools

**Faust Compiler Benchmark Tools** is a suite of utilities designed to analyze and measure the performance of the C++ code generated by the Faust compiler. These tools are particularly useful when developing new compilation strategies, as they ensure correctness and evaluate performance impacts.

## Tools Overview

Assuming you have compiled `foo.dsp` into `foo.cpp`, the following tools are available:

1. **`fcbenchtool foo.cpp`**  
   Generates a binary (`foo`) to measure the performance of the `compute` method in `foo.cpp`.

2. **`fcasmtool foo.cpp`**  
   Produces an assembly file (`foo.s`) for inspecting the generated assembly code.

3. **`fcanalyze foo.cpp`**  
   Performs static analysis on `foo.cpp` to identify potential issues.

4. **`fcplottool foo.cpp`**  
   Creates a binary (`foo`) that, when executed, prints or plots the impulse response of `foo.cpp`.

5. **`fccomparetool foo1.cpp foo2.cpp`**  
   Compares the impulse responses of `foo1.cpp` and `foo2.cpp` using `fcplottool`.

6. **`fcdebugtool foo.cpp`**  
   Similar to `fcplottool`, but produces a debug-enabled binary for use with `gdb`.
   
7. **`fcexplorer.py`**: A Python script to explore various Faust compilation options and their impact on the generated C++ code.


---

## Installation

The tools can be installed with the following command:

```bash
sudo ./install.sh
```

- **Binaries**: Installed in `/usr/local/bin`.
- **Dependencies**: Stored in `/usr/local/share/fcbenchtool`.

---

## Main Tool: `fcbenchtool`

The primary tool, `fcbenchtool`, is used to benchmark the performance of C++ implementations generated by Faust. This involves generating various implementations (e.g., `foo1.cpp`, `foo2.cpp`, etc.) by varying Faust compiler options and comparing their performance.

### How It Works

1. **Code Wrapping**:  
   `fcbenchtool` wraps the original C++ source file between a header and footer to enable performance measurement.
   
2. **Optimized Compilation**:  
   The code is compiled with the following options:
   - `-O3` (high optimization)
   - `-ffast-math` (faster floating-point computations)
   - `-march=native` (architecture-specific optimizations)

3. **Performance Measurement**:  
   The resulting binary measures the time (in milliseconds) to process 1 second of sound (44100 samples). The benchmark iterates until the minimal result remains stable over at least 1000 iterations. This iteration count can be customized.

### Workflow Example

```bash
# Step 1: Generate C++ code from a Faust file
faust foo.dsp -o foo.cpp

# Step 2: Compile with fcbenchtool
fcbenchtool foo.cpp

# Step 3: Execute the binary and analyze performance
sudo ./foo
sudo ./foo 250  # Custom iteration count
```

### Custom Compiler and Extensions

You can specify a custom compiler using the `CXX` environment variable and define a custom file extension for the generated binary. For example:

```bash
faust foo.dsp -o foo.cpp
CXX=clang++-19 fcbenchtool foo.cpp .cl19
sudo ./foo.cl19
```


## Additional Tools

### `fcasmtool`:  
Use to inspect the assembly code generated by the C++ compiler.

```bash
fcasmtool foo.cpp
```

### `fcanalyze`:  
Run static analysis to detect potential issues in `foo.cpp`.

```bash
fcanalyze foo.cpp
```

### `fcplottool` and `fccomparetool`:  

- Plot the impulse response of `foo.cpp`:

  ```bash
  fcplottool foo.cpp
  sudo ./foo
  ```

- Compare impulse responses between two files:

  ```bash
  fccomparetool foo1.cpp foo2.cpp
  ```

### `fcdebugtool`:  
Build a debug-enabled binary for analysis with `gdb`:

```bash
fcdebugtool foo.cpp
gdb ./foo
```

### `fcexplorer.py`:  
Explore various Faust compilation options to observe their impact on the generated C++ code.

```bash
fcexplorer.py -mcd "0 2 4 8" -vec "" foo.dsp...
```

will generate the 8 corresponding C++ files. The generated files will be named `foo_mcd0.cpp`, `foo_mcd0_vec.cpp`, `foo_mcd2.cpp`, etc. In the example `-vec ""`  indicates an option that can be present or not, without additional arguments.
